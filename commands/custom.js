const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');
const { CustomCommand } = require('../models');
const { logger } = require('../utils/logger');

module.exports = {
    data: new SlashCommandBuilder()
        .setName('custom')
        .setDescription('üé® √ñzel komut y√∂netimi')
        .addSubcommand(subcommand =>
            subcommand
                .setName('create')
                .setDescription('‚ûï Yeni √∂zel komut olu≈ütur')
                .addStringOption(option =>
                    option.setName('isim')
                        .setDescription('Komut adƒ± (sadece harf, sayƒ± ve tire)')
                        .setRequired(true)
                )
                .addStringOption(option =>
                    option.setName('i√ßerik')
                        .setDescription('Komut i√ßeriƒüi (variables: {user}, {guild}, {channel}, {args})')
                        .setRequired(true)
                )
                .addStringOption(option =>
                    option.setName('a√ßƒ±klama')
                        .setDescription('Komut a√ßƒ±klamasƒ±')
                        .setRequired(false)
                )
                .addStringOption(option =>
                    option.setName('takma-adlar')
                        .setDescription('Komut takma adlarƒ± (virg√ºlle ayƒ±rƒ±n)')
                        .setRequired(false)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('edit')
                .setDescription('‚úèÔ∏è √ñzel komutu d√ºzenle')
                .addStringOption(option =>
                    option.setName('isim')
                        .setDescription('D√ºzenlenecek komut adƒ±')
                        .setRequired(true)
                        .setAutocomplete(true)
                )
                .addStringOption(option =>
                    option.setName('i√ßerik')
                        .setDescription('Yeni komut i√ßeriƒüi')
                        .setRequired(false)
                )
                .addStringOption(option =>
                    option.setName('a√ßƒ±klama')
                        .setDescription('Yeni a√ßƒ±klama')
                        .setRequired(false)
                )
                .addBooleanOption(option =>
                    option.setName('durum')
                        .setDescription('Komut aktif olsun mu?')
                        .setRequired(false)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('delete')
                .setDescription('üóëÔ∏è √ñzel komutu sil')
                .addStringOption(option =>
                    option.setName('isim')
                        .setDescription('Silinecek komut adƒ±')
                        .setRequired(true)
                        .setAutocomplete(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('list')
                .setDescription('üìã √ñzel komutlarƒ± listele')
                .addStringOption(option =>
                    option.setName('kategori')
                        .setDescription('Listelenecek kategori')
                        .addChoices(
                            { name: 'üìù Genel', value: 'general' },
                            { name: 'üé≠ Eƒülence', value: 'fun' },
                            { name: 'üì¢ Duyuru', value: 'announcement' },
                            { name: 'üìö Bilgi', value: 'info' },
                            { name: 'üé® Diƒüer', value: 'other' }
                        )
                        .setRequired(false)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('info')
                .setDescription('‚ÑπÔ∏è √ñzel komut bilgilerini g√∂r√ºnt√ºle')
                .addStringOption(option =>
                    option.setName('isim')
                        .setDescription('Bilgileri g√∂r√ºnt√ºlenecek komut adƒ±')
                        .setRequired(true)
                        .setAutocomplete(true)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('embed')
                .setDescription('üìÑ Embed ile √∂zel komut olu≈ütur')
                .addStringOption(option =>
                    option.setName('isim')
                        .setDescription('Komut adƒ±')
                        .setRequired(true)
                )
                .addStringOption(option =>
                    option.setName('ba≈ülƒ±k')
                        .setDescription('Embed ba≈ülƒ±ƒüƒ±')
                        .setRequired(true)
                )
                .addStringOption(option =>
                    option.setName('a√ßƒ±klama')
                        .setDescription('Embed a√ßƒ±klamasƒ±')
                        .setRequired(true)
                )
                .addStringOption(option =>
                    option.setName('renk')
                        .setDescription('Embed rengi (hex kodu, √∂rn: #ff0000)')
                        .setRequired(false)
                )
                .addStringOption(option =>
                    option.setName('thumbnail')
                        .setDescription('Embed thumbnail URL\'i')
                        .setRequired(false)
                )
        )
        .addSubcommand(subcommand =>
            subcommand
                .setName('permissions')
                .setDescription('üîê Komut izinlerini ayarla')
                .addStringOption(option =>
                    option.setName('isim')
                        .setDescription('ƒ∞zinleri ayarlanacak komut adƒ±')
                        .setRequired(true)
                        .setAutocomplete(true)
                )
                .addRoleOption(option =>
                    option.setName('rol-ekle')
                        .setDescription('Komutu kullanabilecek rol ekle')
                        .setRequired(false)
                )
                .addRoleOption(option =>
                    option.setName('rol-√ßƒ±kar')
                        .setDescription('Komut izni √ßƒ±karƒ±lacak rol')
                        .setRequired(false)
                )
                .addBooleanOption(option =>
                    option.setName('herkes')
                        .setDescription('Herkes bu komutu kullanabilsin mi?')
                        .setRequired(false)
                )
        ),

    async autocomplete(interaction) {
        const focusedValue = interaction.options.getFocused();
        const commands = await CustomCommand.findAll({
            where: { 
                guildId: interaction.guild.id,
                name: {
                    [require('sequelize').Op.like]: `%${focusedValue}%`
                }
            },
            limit: 25
        });

        const choices = commands.map(cmd => ({
            name: `${cmd.name} - ${cmd.description?.substring(0, 50) || 'A√ßƒ±klama yok'}`,
            value: cmd.name
        }));

        await interaction.respond(choices);
    },

    async execute(interaction) {
        const subcommand = interaction.options.getSubcommand();

        // Yetki kontrol√º (create, edit, delete, permissions i√ßin)
        const adminCommands = ['create', 'edit', 'delete', 'permissions', 'embed'];
        if (adminCommands.includes(subcommand) && !interaction.member.permissions.has(PermissionFlagsBits.ManageGuild)) {
            const errorEmbed = new EmbedBuilder()
                .setColor('#ff0000')
                .setTitle('‚ùå Yetkisiz Eri≈üim')
                .setDescription('Bu komutu kullanabilmek i√ßin **Sunucuyu Y√∂net** yetkisine sahip olmanƒ±z gerekiyor!')
                .setTimestamp();
            
            return interaction.reply({ embeds: [errorEmbed], ephemeral: true });
        }

        try {
            switch (subcommand) {
                case 'create':
                    await this.handleCreate(interaction);
                    break;
                case 'edit':
                    await this.handleEdit(interaction);
                    break;
                case 'delete':
                    await this.handleDelete(interaction);
                    break;
                case 'list':
                    await this.handleList(interaction);
                    break;
                case 'info':
                    await this.handleInfo(interaction);
                    break;
                case 'embed':
                    await this.handleEmbedCreate(interaction);
                    break;
                case 'permissions':
                    await this.handlePermissions(interaction);
                    break;
            }
        } catch (error) {
            logger.error('Custom komutunda hata', error, { subcommand, user: interaction.user.id });
            
            const errorEmbed = new EmbedBuilder()
                .setColor('#ff0000')
                .setTitle('‚ùå Custom Komut Hatasƒ±')
                .setDescription('Custom komut i≈ülemi sƒ±rasƒ±nda bir hata olu≈ütu!')
                .setTimestamp();

            if (interaction.replied || interaction.deferred) {
                await interaction.followUp({ embeds: [errorEmbed], ephemeral: true });
            } else {
                await interaction.reply({ embeds: [errorEmbed], ephemeral: true });
            }
        }
    },

    async handleCreate(interaction) {
        const name = interaction.options.getString('isim').toLowerCase();
        const content = interaction.options.getString('i√ßerik');
        const description = interaction.options.getString('a√ßƒ±klama') || '';
        const aliasesStr = interaction.options.getString('takma-adlar');

        // Komut adƒ± validasyonu
        if (!/^[a-z0-9-_]+$/.test(name)) {
            const errorEmbed = new EmbedBuilder()
                .setColor('#ff0000')
                .setTitle('‚ùå Ge√ßersiz Komut Adƒ±')
                .setDescription('Komut adƒ± sadece k√º√ß√ºk harf, sayƒ±, tire ve alt √ßizgi i√ßerebilir!')
                .setTimestamp();
            
            return interaction.reply({ embeds: [errorEmbed], ephemeral: true });
        }

        // Reserved komut adlarƒ±
        const reservedNames = ['help', 'ping', 'play', 'custom', 'mod', 'economy', 'level', 'ticket', 'giveaway', 'welcome', 'guard'];
        if (reservedNames.includes(name)) {
            const errorEmbed = new EmbedBuilder()
                .setColor('#ff0000')
                .setTitle('‚ùå Rezerve Komut Adƒ±')
                .setDescription('Bu komut adƒ± sistem komutlarƒ± i√ßin rezerve edilmi≈ütir!')
                .setTimestamp();
            
            return interaction.reply({ embeds: [errorEmbed], ephemeral: true });
        }

        await interaction.deferReply();

        try {
            // Mevcut komut kontrol√º
            const existingCommand = await CustomCommand.findOne({
                where: {
                    guildId: interaction.guild.id,
                    name: name
                }
            });

            if (existingCommand) {
                const errorEmbed = new EmbedBuilder()
                    .setColor('#ff0000')
                    .setTitle('‚ùå Komut Zaten Mevcut')
                    .setDescription(`**${name}** adƒ±nda bir komut zaten mevcut!`)
                    .setTimestamp();
                
                return interaction.editReply({ embeds: [errorEmbed] });
            }

            // Aliases parse et
            const aliases = aliasesStr ? aliasesStr.split(',').map(a => a.trim().toLowerCase()) : [];

            // Yeni komut olu≈ütur
            const customCommand = await CustomCommand.create({
                guildId: interaction.guild.id,
                createdBy: interaction.user.id,
                name: name,
                content: content,
                description: description,
                aliases: aliases,
                contentType: 'text'
            });

            const successEmbed = new EmbedBuilder()
                .setColor('#00ff00')
                .setTitle('‚úÖ √ñzel Komut Olu≈üturuldu')
                .setDescription(`**${name}** komutu ba≈üarƒ±yla olu≈üturuldu!`)
                .addFields(
                    { name: 'üìù Komut Adƒ±', value: name, inline: true },
                    { name: 'üìÑ A√ßƒ±klama', value: description || 'A√ßƒ±klama yok', inline: true },
                    { name: 'üî§ Takma Adlar', value: aliases.length > 0 ? aliases.join(', ') : 'Yok', inline: true },
                    { name: 'üìä Kullanƒ±m', value: `\`${name}\` veya \`!${name}\``, inline: false },
                    { name: 'üéØ ƒ∞√ßerik √ñnizleme', value: content.length > 100 ? content.substring(0, 100) + '...' : content, inline: false }
                )
                .setFooter({
                    text: `Olu≈üturan: ${interaction.user.username}`,
                    iconURL: interaction.user.displayAvatarURL()
                })
                .setTimestamp();

            await interaction.editReply({ embeds: [successEmbed] });

        } catch (error) {
            logger.error('Custom command create hatasƒ±', error);
        }
    },

    async handleList(interaction) {
        const category = interaction.options.getString('kategori');

        const whereClause = {
            guildId: interaction.guild.id,
            enabled: true
        };

        if (category) {
            whereClause.category = category;
        }

        const customCommands = await CustomCommand.findAll({
            where: whereClause,
            order: [['usageCount', 'DESC'], ['name', 'ASC']],
            limit: 20
        });

        if (customCommands.length === 0) {
            const noCommandsEmbed = new EmbedBuilder()
                .setColor('#ffa500')
                .setTitle('üìã √ñzel Komut Yok')
                .setDescription(category ? `**${category}** kategorisinde √∂zel komut bulunmuyor!` : 'Hen√ºz hi√ß √∂zel komut olu≈üturulmamƒ±≈ü!')
                .addFields({
                    name: 'üí° ƒ∞pucu',
                    value: '`/custom create` komutu ile yeni √∂zel komutlar olu≈üturabilirsiniz!',
                    inline: false
                })
                .setTimestamp();
            
            return interaction.reply({ embeds: [noCommandsEmbed] });
        }

        let description = '';
        customCommands.forEach((cmd, index) => {
            const usage = cmd.usageCount || 0;
            const statusEmoji = cmd.enabled ? '‚úÖ' : '‚ùå';
            description += `${index + 1}. ${statusEmoji} **${cmd.name}**\n`;
            description += `   ‚îî ${cmd.description || 'A√ßƒ±klama yok'} ‚Ä¢ ${usage} kullanƒ±m\n\n`;
        });

        const listEmbed = new EmbedBuilder()
            .setColor('#0099ff')
            .setTitle('üìã √ñzel Komutlar')
            .setDescription(description)
            .addFields({
                name: 'üìä ƒ∞statistikler',
                value: `Toplam **${customCommands.length}** komut${category ? ` (${category} kategorisi)` : ''}`,
                inline: false
            })
            .setFooter({
                text: `Detaylƒ± bilgi i√ßin: /custom info <komut_adƒ±>`,
                iconURL: interaction.guild.iconURL()
            })
            .setTimestamp();

        await interaction.reply({ embeds: [listEmbed] });
    },

    // Variables i≈üleme fonksiyonu
    processVariables(content, interaction, args = []) {
        return content
            .replace(/{user}/g, interaction.user.toString())
            .replace(/{user\.mention}/g, interaction.user.toString())
            .replace(/{user\.username}/g, interaction.user.username)
            .replace(/{user\.tag}/g, interaction.user.tag)
            .replace(/{user\.id}/g, interaction.user.id)
            .replace(/{guild}/g, interaction.guild.name)
            .replace(/{guild\.name}/g, interaction.guild.name)
            .replace(/{guild\.id}/g, interaction.guild.id)
            .replace(/{guild\.memberCount}/g, interaction.guild.memberCount.toString())
            .replace(/{channel}/g, interaction.channel.toString())
            .replace(/{channel\.name}/g, interaction.channel.name)
            .replace(/{channel\.id}/g, interaction.channel.id)
            .replace(/{args}/g, args.join(' '))
            .replace(/{args\.(\d+)}/g, (match, index) => args[parseInt(index)] || '')
            .replace(/{date}/g, new Date().toLocaleDateString('tr-TR'))
            .replace(/{time}/g, new Date().toLocaleTimeString('tr-TR'))
            .replace(/{timestamp}/g, `<t:${Math.floor(Date.now() / 1000)}:F>`)
            .replace(/{random\.(\d+)-(\d+)}/g, (match, min, max) => {
                return Math.floor(Math.random() * (parseInt(max) - parseInt(min) + 1)) + parseInt(min);
            });
    }
};



